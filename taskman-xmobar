#!/usr/bin/env python3

import json
import subprocess
import sys
import time
from pathlib import Path


def format_duration(seconds):
    """Format seconds as HH:MM:SS"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    return f"{hours:02d}:{minutes:02d}:{secs:02d}"


def get_remaining_time_color(remaining_time, total_duration):
    """Get color for remaining time based on how much time is left"""
    if remaining_time <= 0:
        return "#AAA"  # Grey for expired/no time

    # Calculate percentage of time remaining
    percentage = remaining_time / total_duration if total_duration > 0 else 0

    if percentage > 0.5:
        return "#8F8"  # Green for plenty of time
    elif percentage > 0.2:
        return "#FF8"  # Yellow for moderate time
    else:
        return "#F88"  # Orange/red for little time


def truncate_task(task_description, max_length=20):
    """Truncate task description to max_length, adding ... if needed"""
    if len(task_description) <= max_length:
        return task_description
    return task_description[:17] + "..."


def get_taskman_data():
    """Get data from taskman CLI"""
    try:
        # Get current status
        status_result = subprocess.run(
            ["taskman", "status"],
            capture_output=True,
            text=True,
            check=True
        )
        status_data = json.loads(status_result.stdout)

        # Get weekly summary
        summary_result = subprocess.run(
            ["taskman", "summary"],
            capture_output=True,
            text=True,
            check=True
        )
        summary_data = json.loads(summary_result.stdout)

        return status_data, summary_data

    except (subprocess.CalledProcessError, json.JSONDecodeError):
        # Return empty data on error
        return {"blocks": []}, {"aggregate": {"total_current_time": 0}}


def format_output():
    """Format the xmobar output"""
    status_data, summary_data = get_taskman_data()

    # Get weekly total time
    weekly_total = summary_data.get("aggregate", {}).get("total_current_time", 0)
    weekly_formatted = format_duration(weekly_total)

    # Check if there's an active block
    current_block = None
    if status_data.get("blocks"):
        current_block = status_data["blocks"][0]

    if not current_block or not current_block.get("active", False):
        # No active block
        remaining_formatted = format_duration(0)
        remaining_color = "#AAA"
        task_text = ""
    else:
        # Active block exists
        remaining_time = current_block.get("time_remaining", 0)
        total_duration = current_block.get("duration", 1500)
        is_paused = current_block.get("paused", False)

        if is_paused:
            # Block is paused - show current time in light grey
            current_time = current_block.get("current_time", 0)
            remaining_formatted = format_duration(current_time)
            remaining_color = "#CCC"
        else:
            # Block is active - show remaining time with color coding
            remaining_formatted = format_duration(max(0, remaining_time))
            remaining_color = get_remaining_time_color(remaining_time, total_duration)

        # Get current task description
        active_task = current_block.get("active_task")
        if active_task and active_task.get("description"):
            task_description = active_task["description"]
            if task_description == "(no task set)":
                task_text = " | [not started]"
            else:
                task_text = " | " + truncate_task(task_description)
        else:
            task_text = " | [not active]"

    # Format the output
    output = f"<fc=#8AF>{weekly_formatted}</fc> | <fc={remaining_color}>{remaining_formatted}</fc>{task_text}"
    return output


def main():
    """Main loop - output formatted data every second"""
    try:
        while True:
            output = format_output()
            print(output, flush=True)
            time.sleep(1)
    except KeyboardInterrupt:
        sys.exit(0)
    except Exception as e:
        # Log error and continue
        error_log = Path.home() / ".config" / "taskman" / "errors.log"
        error_log.parent.mkdir(exist_ok=True)
        timestamp = time.strftime("%Y-%m-%dT%H:%M:%S.000Z", time.gmtime())
        with open(error_log, "a") as f:
            f.write(f"[{timestamp}] ERROR: taskman-xmobar: {e}\n")
        sys.exit(1)


if __name__ == "__main__":
    main()
